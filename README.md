# Паттерны поддержания консистентности

### Задание
Реализовать сервис заказа, сервис биллинга, сервис нотификаций.
При создании пользователя, необходимо создавать аккаунт в сервисе биллинга. 

В сервисе биллинга должна быть возможность положить деньги на аккаунт и снять деньги.

Сервис нотификаций позволяет отправить сообщение на email и позволяет получить список сообщений по методу API.

Пользователь может создать заказ. У заказа есть параметр - цена заказа.

Заказ происходит в 2 этапа:
1. Сначала снимаем деньги с пользователя с помощью сервиса биллинга.
2. Отсылаем пользователю сообщение на почту с результатами оформления заказа. Если биллинг подтвердил платеж, должно отослаться письмо счастья. Если нет, то письмо горя.
* Упрощаем и считаем, что ничего плохого с сервисами происходить не может (они не могут падать и т.д.). Сервис нотификаций на самом деле не отправляет, а просто сохраняет в БД.

### Теоритическая часть
Спроектировать взаимодействие сервисов при создании заказов. 
Предоставить варианты взаимодействий в следующих стилях в виде sequence диаграммы с описанием API на IDL:
* Только HTTP взаимодействие
* Событийное взаимодействие с использование брокера сообщений для нотификаций (уведомлений)
* Event Collaboration cтиль взаимодействия с использованием брокера сообщений

### Диаграммы
![Sequence Diagrams](https://user-images.githubusercontent.com/60660331/189902157-d3b550da-fd3f-42f2-b827-4c26d657cf2a.png)

![Sequence Diagrams_Http+Broker](https://user-images.githubusercontent.com/60660331/189904487-983723c0-adfd-4afb-914b-442baaf10d6f.png)

![Sequence Diagrams_EventColabaration](https://user-images.githubusercontent.com/60660331/189903265-1ab4ee4d-96c5-4753-ba84-5e1f1ff97143.png)

Для реализации будет использован второй вариант. Так как снятие наличных и изменение статуса заказа можно делать синхронно, а отправка уведомления о заказе может происходить довольно долго и имеет смысл ее запустить асинхронно отправив сообщение в брокер с последующей отправкой письма.

### Практическая часть
Выбрать один из вариантов и реализовать его.
На выходе должны быть: 
1. Описание архитектурного решения и схема взаимодействия сервисов (в виде картинки)
2. Команда установки приложения (из helm-а или из манифестов). Обязательно указать в каком namespace нужно устанавливать.
3. Тесты постмана, которые прогоняют сценарий:
* Создать пользователя. Должен создаться аккаунт в биллинге.
* Положить деньги на счет пользователя через сервис биллинга.
* Сделать заказ, на который хватает денег.
* Посмотреть деньги на счету пользователя и убедиться, что их сняли.
* Посмотреть в сервисе нотификаций отправленные сообщения и убедиться, что сообщение отправилось.
* Сделать заказ, на который не хватает денег.
* Посмотреть деньги на счету пользователя и убедиться, что их количество не поменялось.
* Посмотреть в сервисе нотификаций отправленные сообщения и убедиться, что сообщение отправилось.
В тестах обязательно наличие {{baseUrl}} для урла с использованием домена arch.homework в качестве initial значения {{baseUrl}},
отображение данных запроса и данных ответа при запуске из командной строки с помощью newman

### Реализация

![Реализация](https://user-images.githubusercontent.com/60660331/189918475-e29ffcea-9232-407d-a503-52a005cae6b7.png)

0. В качестве маршрутизации траифка между пользователем и сервиса используется NGINX Ingress контроллер.

2. Создание пользователя. 
* Пользователь отправляет запрос в сервис пользователей передавая туда GUID и имя.
* Сервис пользователей отправляет запрос запрос в сервис биллинга на создание аккаунта с GUID пользователя.
* Получив от сервиса биллинга ответ, сервис пользователь возвращает статус ОК и созданного пользователя.
  
2. Пополнение счета
* Пользователь отправляет запрос на поплнение счета, передавая GUID пользователя и значение на которое нужно увеличть баланс.  
* Сервис биллинга отправляет статус ОК и остаток на счете пользователя.
  
3. Создание заказа
* Пользователь отправляет запрос на создание заказа, передавая GUID пользователя, GUID заказа и его стоимость.
* Сервис заказов отправляет статус ОК и созданный заказ.
  
4. Оплата заказа
* Пользователь отравляет запрос на оплату заказа, передавая GUID пользователя, GUID заказа и его стоимость.
* Сервис биллинга проверяет баланс пользователя по его GUID. Если баланс больше, чем стоимость заказа, то сервис выполняет запрос в сервис заказа на обновление статуса заказа "Оплачен", иначе - "Отменен". 
* Сервис заказов обновляет статус заказа, возвращая текущее состояние заказа и отправляет в брокер сообщений событие "Заказ оплачен" или "Заказ отменен", содержащее GUID пользователя, GUID заказа и результат оплаты.
  
5. Уведомление
* Сервис нотификаций прослушивает очередь сообщений.
* При поступлении события "Заказ оплачен" или "Заказ отменен" сохраняет в БД уведомления.
* Пользователь обращается с запросом на получение списка уведомлений передавая свой GUID.
* Сервис нотификаций делает запрос в БД на получение уведомлений содержащий GUID пользователя и возвращает резудьтат в виде списка.

### Инструкция по установке
1. Поставить NGINX ингресс через Helm, если не установлен:
```
helm upgrade --install ingress-nginx ingress-nginx --repo https://kubernetes.github.io/ingress-nginx --namespace ingress-nginx --create-namespace --set controller.admissionWebhooks.enabled=false
```
2. Скопировать текущий репозиторий:
```
git clone https://github.com/Flipmachin1001/Streamprocessing.git
```
3. Перейти в созданный каталог:
```
cd Streamproccesing
```
4. Установить сервисы через Helm:
```
helm install orders ./helm-chart
```
5. Дождаться пока установиться RabbitMQ. Для проверки готовности выполнить команду:
```
kubectl get pod/orders-rabbitmq-0
```
6. Запустить тесты Postman командой:
```
newman run StreamProccesing.postman_collection.json
```
7. Удалить сервисы через Helm:
```
helm uninstall orders
```
